## Variables and Mutability

จากที่ได้กล่าวไปแล้วในบทที่ 2 ว่าโดยปกติตัวแปรจะเป็นแบบเปลี่ยนแปลงค่าไม่ได้ นี่เป็นหนึ่งในสิ่งที่ Rust พยายามทำให้คุณเขียนโค้ดให้ปลอดภัยและง่ายต่อการทำงานแบบคู่ขนานในแบบที่ Rust นำเสนอได้ง่ายขึ้น แต่คุณก็ยังสามารถใช้ตัวเลือกเพื่อทำให้ตัวแปร เปลี่ยนค่าได้อยู่ดี เรามาดูกันว่า Rust จะยั่วให้คุณชอบ ตัวแปรที่เปลี่ยนค่าไม่ได้นี้ อย่างไร และทำไมเราถึงต้องทำแบบนั้น และทำไมบางครั้งคุณถึงยังอยากมีทางเลือกอื่นอีก

เมื่อตัวแปรไม่สามารถเปลี่ยนค่าได้ หมายความว่า เมื่อค่าใดก็ตามถูกนำไปใส่ในชื่อใดแล้ว คุณไม่สามารถเปลี่ยนค่านั้นได้อีก เพื่ออธิบายสิ่งนี้ เรามาสร้างโปรเจ็คใหม่กัน ให้ชื่อว่า *variables* เอาไว้ในไดเร็คทอรี่ *projects* ด้วยการสั่งว่า `cargo new variables`

จากนั้นในไดเร็คทอรี่ *variables* ให้เปิดไฟล์ *src/main.rs* แล้วเอาโค้ดนี้ไปทับโดยยังไม่ต้องคอมไพล์:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

จากนั้นบันทึกไฟล์แล้วรันโปรแกรมด้วยคำสั่ง `cargo run` คุณควรได้รับ error ตามที่เห็นนี้:

```text
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```

ตัวอย่างนี้แสดงให้เห็นว่าตัวคอมไพเลอร์จะช่วยคุณหา error ในโปรแกรมคุณได้อย่างไร แต่ถึงแม้ว่าการที่คอมไพเลอร์แสดงข้อความ error จะดูน่าผิดหวัง แต่มันก็แค่หมายความว่าโปรแกรมของคุณมันยังไม่ปลอดภัยพอให้คุณทำงานได้เท่านั้น มัน *ไม่ได้* หมายความว่าคุณเป็นโปรแกรมเมอร์ที่ไม่เก่ง เพราะแม้แต่พวกผู้คลั่งไคล้ Rust ที่มีประสบการณ์สูงๆก็ยังได้รับ error ตอนคอมไพล์อยู่เสมอ

ข้อความ error นี้แสดงให้คุณรู้ว่า คุณไม่สามารถใส่ให้ตัวแปร x สองครั้งได้ เพราะว่าคุณพยายามกำหนดค่าครั้งที่สองให้ตัวแปร `x` ซึ่งมันเป็นแบบเปลี่ยนแปลงค่าไม่ได้นั่นเอง

การได้รับ error ตอนคอมไพล์นี้มีส่วนสำคัญมาก เมื่อเราพยายามจะเปลี่ยนค่าที่เคยถูกกำหนดไปแล้วกับตัวแปรชนิดแก้ค่าไม่ได้ เพราะมันอาจทำให้เกิดบั๊กได้ง่ายๆเลย เพราะถ้าที่หนึ่งของโค้ดเราทำงานบนความเชื่อที่ว่าค่านี้จะไม่ถูกเปลี่ยนตลอดกาล และอีกส่วนของโค้ดพยายามจะไปแก้มัน ไอ้ส่วนแรกมันก็ไม่ได้คิดเผื่อไว้ด้วยว่าต้องทำยังไง ไอ้บั๊กประเภทนี้มันหายากมากๆ โดยเฉพาะเมื่อโค้ดสองส่วนนี้ จะเปลี่ยนค่านี้แค่ *บางโอกาส* อีกต่างหาก

ตัวคอมไพเลอร์ของ Rust รับประกันว่า เมื่อเราตั้งใจว่าค่าไหนจะไม่ถูกเปลี่ยน มันจะต้องไม่ถูกเปลี่ยนแน่นอน นั่นหมายความว่า เมื่อเวลาที่คุณกำลังอ่านและเขียนโค้ดอยู่ คุณไม่ต้องไปสนใจว่าค่านี้จะไปเปลี่ยนตอนไหน โค้ดคุณจะตรงไปตรงมา

แต่ว่า ตัวแปรที่แก้ค่าได้ ก็มีประโยชน์ อย่างที่เห็นในบทที่ 2 แล้วว่าโดยปกติตัวแปรจะแก้ค่าไม่ได้ แต่เราก็ทำให้มันแก้ค่าได้ด้วยการเพิ่ม `mut` ไปข้างหน้าตัวแปร และมันยังหมายความถึงว่าผู้ที่อ่านโค้ดนี้จะรู้ว่าต้องมีส่วนใดส่วนหนึ่งของโค้ดจะมาเปลี่ยนค่านี้

เพื่อแสดงตัวอย่าง ลองเปลี่ยน *src/main.rs* ตามนี้:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

เมื่อเรารันโปรแกรม เราจะได้:

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

เรายอมให้เปลี่ยนค่า `x` จาก `5` ไปเป็น `6` ได้ด้วยการใช้ `mut` ในบางกรณี คุณอาจจะต้องการให้ตัวแปร เปลี่ยนค่าได้ เพราะมันจะทำให้คุณเขียนโค้ดสะดวกขึ้นมากกว่าการใช้ตัวแปรที่เปลี่ยนค่าไม่ได้

มันมีหลายๆอย่างที่ต้องแลก ถ้าคุณต้องการป้องกันการเกิดบั๊ก ตัวอย่างเช่น ในกรณีที่คุณใช้ data structures ที่ใหญ่มากๆ การสร้างอินสแตนซ์ที่เปลี่ยนค่าได้ จะทำให้มันทำงานเร็วกว่าที่จะมาสำเนาของไปสร้างใหม่อยู่เรื่อยๆ ในขณะที่ถ้ามันเป็น data structures ที่เล็ก การสร้างอินสแตนซ์ใหม่และเขียนแบบ functional style อาจจะทำให้เราคิดได้ง่ายขึ้น นั่นหมายความว่า ขึ้นอยู่กับว่า คุณจะยอมให้ประสิทธิภาพตกลงเพื่อแลกกับความชัดเจนที่เพิ่มขึ้นหรือไม่

### Differences Between Variables and Constants

การที่เราพูดกันถึงตัวแปรที่ไม่สามารถเปลี่ยนค่าได้ อาจจะทำให้คุณไปนึกถึงหลักการของภาษาโปรแกรมมิ่งอื่นส่วนใหญ่ที่จะมี *constants* ซึ่งมันคล้ายกับตัวแปรที่แก้ค่าไม่ได้เลย เพราะ constant เป็นค่าที่ใส่เข้าไปในชื่อไหนแล้วก็เปลี่ยนค่าไม่ได้อีกต่อไป แต่มันก็มีความแตกต่างกันเล็กน้อยระหว่าง constants กับตัวแปร

อย่างแรก คุณไม่สามารถใช้ `mut` กับ constants ได้ เพระา constants ไม่ใช่แค่เปลี่ยนค่าไม่ได้โดยปกติ แต่มันเปลี่ยนค่าไม่ได้เลยด้วยซ้ำ

คุณประกาศ constants ได้ด้วยการใช้คำ `const` แทนคำว่า `let` และ *ต้อง* ระบุ type ด้วย แล้วเราจะไปรู้เรื่อง type กับการประกาศ type กันในบทหน้า [“Data Types,”][data-types]<!-- ignore --> เฉพาะฉะนั้น อย่าเพิ่งกังวลเกี่ยวกับมันในตอนนี้ แค่รู้ไว้ว่าเราต้องประกาศ type ให้มันเสมอแค่นั้นพอ

เราสามารถประกาศ constants ไว้ที่สโคปไหนก็ได้ รวมทั้งที่ global ซึ่งเหมาะสำหรับค่าที่คุณต้องการให้รับรู้ทั่วทั้งโปรแกรม

สุดท้าย สิ่งที่ต่างกันก็คือ การกำหนดค่าให้มันจะต้องทำตอนที่ประกาศเท่านั้น ไม่สามารถใช้ค่าที่ได้คืนมาจากฟังก์ชั่นหรือ ค่าใดๆที่เกินตอน runtime ได้เลย

นี่คือตัวอน่างการประกาศ constant ชื่อ `MAX_POINTS` พร้อมกำหนดค่าให้มันเท่ากับ 100,000 (การประกาศชื่อ constant ในภาษา Rust โดยส่วนมากจะใช้ตัวอักษรตัวใหญ่ร่วมกับขีดล่างเป็นตัวคั่นระหว่างคำ และขีดล่างนี้ยังใช้กับตัวเลข แทนการใช้ลูกน้ำเพื่อช่วยให้อ่านง่ายขึ้นอีกด้วย)

```rust
const MAX_POINTS: u32 = 100_000;
```

constant จะคงอยู่ตลอดเวลาที่โปรแกรมทำงาน ในสโคปที่มันถูกประกาศไว้ ซึ่งมันมีประโยชน์มากในกรณีที่คุณต้องการให้ส่วนต่างๆของโปรแกรมรู้จักค่า ค่าหนึ่ง เช่น ค่าแต้มสูงสุดที่ยอมให้ผู้เล่นเกมทำได้ หรือค่าความเร็วแสง

การใช้ constant กำหนดค่าใดๆลงไปเป็น hardcoded นี้มีประโยชน์ในแง่การดูแลโค้ดในอนาคต และมันยังช่วยให้คุณแก้โค้ดที่เดียวในกรณีที่ถ้ามันจะต้องถูกแก้ไขในอนาคต

### Shadowing

ถ้ายังจำได้ในตอนที่เราทำเกมเดาเลขกันในส่วน [“Comparing the Guess to the
Secret Number”][comparing-the-guess-to-the-secret-number]<!-- ignore --> ในบทที่ 2 คุณสามารถประกาศตัวแปรใหม่โดยใช้ชื่อซ้ำกับตัวแปรก่อนหน้าได้ และตัวแปรตัวใหม่จะเป็นเงาของตัวแปรก่อนหน้านั้น พวกผู้คลั่งไคล้ Rust กล่าวกันว่า เจ้าตัวแปรตัวแรกได้กลายเป็น *เงา* ของตัวแปรที่สอง หมายความว่าเราจะได้ค่าจากตัวแปรที่สองเมื่อตอนที่ใช้งานจริง โดยเราสามารถที่จะทำเงาของตัวแปรได้ด้วยการใช้ 'let` ประกาศชื่อเดิมซ้ำๆแบบนี้:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```

โปรแกรมนี้ประกาส `x` ตัวแรกด้วยการกำหนดค่าเป็น `5` จากนั้นมันกลายเป็นเงาจากการประกาศชื่อเดิมซ้ำ `let x =` ด้วยการเอาค่าเดิมมาบวกเพิ่มไปอีก `1`  แสดงว่าตอนนี้ค่านี้ก็คือ `6` และครั้งที่สาม เราใช้ `let` ทำให้ `x` กลายเป็นเงาอีกรอบด้วยการเอาค่าก่อนหน้านี้มาคูณ `2` แล้วเอาค่ากลับไปใส่ `x` ค่าสุดท้ายก็จะกลายเป็น `12` และเมื่อเรารันโปรแกรมมันจะแสดงผลตามนี้

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
```

การสร้างเงานี้แตกต่างจากการใช้ `mut` เพราะเราจะได้ error ตอนที่คอมไพล์ทันทีถ้าเกิดปัญหาว่าเราพยายามจะยัดค่าให้มันโดยไม่ใช้ `let` ซึ่งการใช้ `let` จะทำให้เรามีโอกาสปรับเปลี่ยนค่ามันได้ก่อนเล็กน้อย แต่ก็จะได้ตัวแปรที่แก้ไขค่าไม่ได้กลับมาในตอนจบ

ความแตกต่างในแง่อื่นระหว่างการใช้ `mut` กับการสร้างเงา ก็คือมันให้ประสิทธิผลดีกว่า เพราะว่าเราใช้ `let` เพื่อประกาศตัวแปรใหม่ มันทำให้เราสามารถเปลี่ยน type มันได้ในขณะที่ใช้ชื่อเดิม ตัวอย่างเช่น โปรแกรมของเราต้องการถามผู้ใช้ว่าต้องการเว้นวรรคกี่ตัวอักษรระหว่างประโยค ด้วยการรับตัวอักษรเว้นวรรคเข้ามา แต่ความจริงเราต้องการเก็บมันเป็นตัวเลข:

```rust
let spaces = "   ";
let spaces = spaces.len();
```

เราสามารถทำแบบนี้ได้ โดยประกาศตัวแปร `spaces` ตัวแรกเป็นสตริง และตัวแปร `spaces` ที่ประกาศครั้งที่สอง ใช้ชื่อเดิมเหมือนตัวแปรตัวแรก แต่มันเป็นตัวเลข ซึ่งการสร้างเงานี้จะช่วยให้เราไม่ต้องสร้างตัวแปรที่ชื่อต่างกันเช่น `spaces_str` กับ `spaces_num` แทนที่จะทำแบบนั้น เราก็ใช้ชื่อเดียวกันไปเลยคือ `spaces` แต่อย่างไรก็ดี ถ้าเราพยายามใช้ `mut` แทนในกรณีที่ต้องการสร้างเงา เราจะได้ error ตอนที่คอมไพล์แทนแบบนี้:

```rust,ignore,does_not_compile
let mut spaces = "   ";
spaces = spaces.len();
```

error นี้บอกว่าเราไม่ได้รับอนุญาตให้เปลี่ยน type ตัวแปรได้:

```text
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &str, found usize
  |
  = note: expected type `&str`
             found type `usize`
```

ถึงตอนนี้เราก็ได้รู้แล้วว่าตัวแปรมันทำงานยังไง ต่อไปเราไปดูกันต่อในรายละเอียดว่ามี type อะไรให้ใช้บ้าง

[comparing-the-guess-to-the-secret-number]:
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
