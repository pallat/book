## Hello, Cargo!

Cargo คือ ตัวจัดการแพ็คเก็จและ บิวด์ระบบของ Rust โดยผู้คลั่งใคล้ Rust ส่วนใหญ่ใช้เครื่องมือนี้สำหรับจัดการโปรเจ็ค เพราะ Cargo ช่วยทำหลายๆสิ่งแทนให้
เช่น ช่วยสร้างโค้ดให้คุณ ดาวน์โหลดไลบรารี่ที่จำเป็นต้องใช้ให้ และช่วยบิวด์ไลบรารี่พวกนั้นด้วย (เราเรียกพวกไลบรารี่ที่โค้ดคุณจำเป็นต้องใช้ว่า *dependencies*)

ยกตัวอย่างง่ายๆก็คือ เจ้าโปรแกรมที่เราเขียนกันไปก่อนหน้านี้ มันไม่มี dependencies อะไรเลยใช่ไหม
ทีนี้ถ้าเราจะบิวด์ Hello, world! ของเราด้วย Cargo มันก็แค่ใช้ส่วนจัดการบิวด์โค้ดเราแค่นั้น แต่ถ้าเราเขียนโค้ดที่ซับซ้อนขึ้น เราก็จะต้องเพิ่ม dependencies เข้าไป และทีนี้ Cargo ก็จะเริ่มมีบทบาทเข้ามาช่วยให้ชีวิตเราง่ายขึ้นล่ะ

นั่นเพราะว่าโปรเจ็ค Rust ส่วนมากจะใช้ Cargo และในหนังสือนี้ก็คาดหวังว่าคุณก็จะใช้ด้วยเช่นกัน โดยเจ้า Cargo นี้จะมาพร้อมกับตัวติดตั้งอยู่แล้ว ซึ่งถ้าคุณใช้ตัวติดตั้งอย่างเป็นทางการอยู่แล้วละก็ มาคุยกันได้ที่
[“Installation”][installation]<!-- ignore -->  แต่ถ้าคุณติดตั้งจากแหล่งที่มาอื่น ลองเช็คดูว่ามี Cargo มาด้วยหรือยัง แล้วการพิมพ์คำสั่งตามนี้บนเทอร์มินัล:

```text
$ cargo --version
```

ถ้าคุณเห็นเลขเวอร์ชั่นโผล่ออกมาก็แสดงว่าคุณมีมันแล้ว แต่ถ้าเห็น error เช่น `command
not found` อะไรทำนองนี้ ก็ให้ไปเปิดเอกสารในส่วนที่ว่าจะติดตั้ง Cargo เดี่ยวๆยังไงก็แล้วกันนะ

### Creating a Project with Cargo

ทีนี้เรามาลองสร้างโปรเจ็คใหม่ด้วย Cargo กันดีกว่า เราจะได้เห็นว่ามันต่างจากที่เราทำกันตอนที่เขียน Hello, world! ยังไงบ้าง เริ่มจากกลับไปที่ไดเร็คทอรี่ *projects* ก่อน (หรือที่ไหนก็ได้ที่เราจะใช้เก็บโปรเจ็ค) แล้วพิมพ์คำสั่งตามนี้:

```text
$ cargo new hello_cargo
$ cd hello_cargo
```

คำสั่งแรกเป็นการสร้างไดเร็คทอรี่ใหม่ชื่อ *hello_cargo* แล้วเราก็จะได้โปรเจ็คชื่อว่า *hello_cargo* ด้วยเลย และ Cargo ก็สร้างไฟล์เริ่มต้นให้เราทันที

เข้าไปในไดเร็คทอรี่ *hello_cargo* แล้วลองดูรายชื่อไฟล์ในนั้น คุณจะเห็นว่า Cargo สร้างไฟล์ให้เรา สองไฟล์ กับอีก หนึ่งไดเร็คทอรี่คือไฟล์: *Cargo.toml* กับไดเร็คทอรี่ชื่อ *src* ที่มีไฟล์ *main.rs* อยู่ข้างใน แถมยังสร้าง git repo ให้เราพร้อม *.gitignore* สวยๆทันทีอีกต่างหาก

> สังเกต: Git จะเป็นตัวจัดการเวอร์ชั่นพื้นฐานที่เตรียมไว้ให้ โดยคุณสามารถเปลี่ยนให้ `cargo new` ไปใช้
> ตัวจัดการเวอร์ชั่นตัวอื่นๆ หรือจะไม่ให้ใช้เลยก็ได้ด้วยการเติม `--vcs` ในคำสั่ง และสำหรับการช่วยเหลือในเรื่องนี้ ให้รันคำสั่ง `cargo new --help`

ทีนี้ให้คุณเปิดไฟล์ *Cargo.toml* จากโปรแกรม text editor ที่คุณชอบ คุณน่าจะได้เห็นอะไรคล้ายกับที่เราแสดงให้เห็นใน Listing 1-2

<span class="filename">Filename: Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2018"

[dependencies]
```

<span class="caption">Listing 1-2: เนื้อความใน *Cargo.toml* ที่ถูกสร้างขึ้นจากคำสั่ง `cargo
new`</span>

ไฟล์นี้เป็นไฟล์รูปแบบ [*TOML*][toml]<!-- ignore --> (*Tom’s Obvious, Minimal
Language*) ที่ Cargo เลือกมาใช้เป็นไฟล์สำหรับเก็บค่าองค์ประกอบ

[toml]: https://github.com/toml-lang/toml

โดยในบรรทัดแรก `[package]` คือส่วนหัวที่แสดงว่าส่วนต่อไปนี้เป็นส่วนขององค์ประกอบของการกำหนดค่าแพ็คเก็จ

สี่บรรทัดต่อมาเป็นการกำหนดค่าที่ Cargo ต้องการใช้เพื่อคอมไพล์: ชื่อ เวอร์ชั่น ใครเขียนโค้ดนี้ และ edition ของ Rust ที่เราใช้ โดย Carego จะดึงเอาชื่อและอีเมล์ของคุณมาจากค่าใน environment ซึ่งถ้ามันไม่ถูกต้อง คุณสามารถแก้ไขมันได้เลย แล้วก็บันทึกไฟล์ไว้ ส่วนเรื่อง `edition` เดี๋ยวเราจะไปกล่าวถึงที่ภาคผนวก E 

บรรทัดสุดท้าย `[dependencies]` เป็นจุดเริ่มต้นของ dependencies ที่จะถูกใช้ในโปรเจ็ค ซึ่ง packages ทั้งหลายใน Rust จะอ้างถึง *crates* ซึ่งเราจะยังไม่ต้องพูดถึงมันในตอนนี้ แต่เราจะพูดถึงมันในโปรเจ็คแรกของบทที่ 2

ตอนนี้ให้เปิดไฟล์ *src/main.rs* แล้วพิจารณากัน:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo ได้สร้างโปรแกรม Hello, world! ให้คุณเหมือนกับที่เราเขียนกันมาแล้วใน Listing 1-1! แต่ที่ต่างกันคือ Cargo สร้างโค้ดนี้ไว้ในไดเร็คทอรี่ *src* แล้วก็ยังมีตัวเก็บองค์ประกอบ *Cargo.toml* อยู่ข้างนอกอีกด้วย

Cargo คาดหวังว่าซอสโค้ดของคุณจะต้องอยู่ในไดเร็คทอรี่ *src* เสมอ และด้านบนสุดของโปรเจ็ค คุณก็จะเห็นของจำพวก ไฟล์ README หรือ license และอะไรก็แล้วแต่ที่ไม่เกี่ยวกับโค้ดเลย
การใช้ Cargo จะช่วยคูณจัดองค์ประกอบของโปรเจ็ค เป็นทุกอย่างให้คุณ และมีให้คุณทุกอย่างแล้ว

ถ้าคุณเริ่มต้นเขียนโปรเจ็คโดยไม่ใช้ Cargo เหมือนที่เราทำกันมาตอน Hello, world! แล้วอยากจะเปลี่ยนมาใช้ Cargo ภายหลัง ก็แค่ย้ายโค้ดเข้าไปไว่้ใน *src*  แล้วก็สร้าง *Cargo.toml* ขึ้นมาเองก็ได้

### Building and Running a Cargo Project

ทีนี้เราลองมาดูว่าจะมีอะไรแตกต่างไปไหม ถ้าเราจะบิวด์และรัน Hello, world! ตัวนี้ด้วย Cargo โดยให้ไปที่ได้เร็คทอรี่ *hello_cargo*  แล้วบิวด์โปรเจ็คด้วยคำัสั่งตามนี้:

```text
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

คำสั่งนี้จะสร้างไฟล์ executable ใน *target/debug/hello_cargo* (หรือ *target\debug\hello_cargo.exe* บน Windows) แทนที่จะเอาไว้ที่ไดเร็คทอรี่ที่คุณอยู่ จากนั้นให้รันโปรแกรมด้วยคำสั่งตามนี้:

```text
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

ถ้าไม่มีอะไรผิดพลาด `Hello, world!` จะแสดงขึ้นมาบนหน้าเทอมอนัล และการรันคำสั่ง `cargo build` ครั้งแรก มันจะสร้างไฟล์ใหม่อีกไฟล์ชื่อ *Cargo.lock* เอาไว้เก็บเวอร์ชั่นของพวก dependencies ของโปรเจ็ค แต่เนื่องจากเรายังไม่มี dependencies อะไร เพราะโปรแกรมเรามันโคตรเล็กเลย และเราก็ไม่ต้องมาแก้ไขไฟล์นี้เอง เพราะ Cargo จะจัดการให้แล้ว

ตอนนี้ เราได้สร้างโปรเจ็คด้วย `cargo build` แล้วก็ทดลองรันดูแล้วด้วย `./target/debug/hello_cargo` แต่เรายังสามารถใช้คำสั่ง `cargo run` ถ้าต้องการให้มันคอมไพล์แล้วก็รันให้เลยในคำสั่งเดียว

```text
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

แจ้งเพื่อทราบว่า ในครั้งนี้เราจะไม่เห็นผลลัพธ์ว่า Cargo ได้คอมไพล์โค้ด `hello_cargo` เพราะมันรู้ว่าไฟล์ยังไม่ได้ถูกแก้ไข ดังนั้นมันจึงแค่รันไบนารี่เดิม แต่ถ้าคุณมีการแก้ไขซอสโค้ดเมื่อไหร่ Cargo จะรู้แล้วจึงค่อยบิวด์ให้ใหม่ก่อนรัน ถ้าเป็นแบบหลังคุณถึงจะเห็นผลลัพธ์แบบนี้:

```text
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

นอกจากนั้น Cargo ยังมีคำสั่ง `cargo check` ไว้สำหรับตรวจสอบเร็วๆ ว่าโค้ดของคุณคอมไพล์ได้หรือไม่ โดยไม่สร้างไฟล์ executable:

```text
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

แล้วทำไมเราจะไม่อยากได้ไฟล์ executable กันล่ะ? บ่อยครั้งที่เราพบว่า `cargo check` นั้นทำงานเร็วว่า `cargo build` เพราะมันข้ามขั้นตอนการสร้างไฟล์ executable ไป ซึ่งถ้าคุณเช็คโปรแกรมคุณอยู่เรื่อยๆในขณะที่เขียนโค้ดด้วยคำสั่ง `cargo check` มันจะทำให้คุณทำงานเร็วขึ้น เหมือนที่ผู้คลั่งไคล้ Rust เขาทำกันเพื่อให้มั่นใจว่าโค้ดมันคอมไพล์ผ่าน และพวกเขาจะรัน `cargo build` เฉพาะเมื่อเขาต้องการจะใช้ executable จริงๆ

เรามาทบทวนกันสักหน่อยว่าได้เรียนรู้อะไรเกี่ยวกับ Cargo กันไปบ้าง:

* เราบิวด์โปรเจ็คด้วยคำสั่ง `cargo build` หรือ `cargo check`
* เราบิวด์แล้วก็รันโปรเจ็คในคำสั่งเดียวด้วย `cargo run`
* แทนที่จะบิวด์โปรแกรมไว้ที่ไดเร็คทอรี่เดียวกับโค้ด Cargo เอามันไปเก็บไว้ที่ *target/debug* แทน

ข้อดีอีกอย่างของการใช้ Cargo คือคำสั่งมันเหมือนกันหมดในทุก OS ไม่ว่าคุณจะทำงานบน Linux และ macOS หรือบน Windows

### Building for Release

เมื่อโปรเจ็คของคุณพร้อมจะปล่อยให้ใช้จริง คุณสามารถใช้คำสั่ง `cargo build
--release` เพื่อคอมไพล์แบบรีดประสิทธิภาพสูงสุด โดยคำสั่งนี้จะสร้างไฟล์ executable ไว้ที่ *target/release* แทนที่จะไว้ใน *target/debug* ซึ่งการรีดประสิทธิภาพนี้จะช่วยให้โปรแกรมทำงานเร็วยิ่งขึ้น แต่อาจจะใช้เวลาคอมไพล์นานหน่อย นั่นเป็นสาเหตุว่าทำไมเราถึงจะต้องมีโปรไฟล์สองแบบที่ต่างกัน แบบแรกใช้สำหรับพัฒนา ที่ต้องการการบิวด์เร็วๆ บ่อยๆ ส่วนอีกแบบใช้สำหรับโปรแกรมที่เสร็จแล้ว พร้อมส่งให้ใช้งานจริง ซึ่งมันไม่ต้องการการคอมไพล์บ่อย แต่ต้องการให้ทำงานได้เร็วที่สุดเท่าที่จะทำได้ ทีนี้ถ้าคุณจะทดสอบการทำงานในแง่ประสิทธิภาพ อย่าลืมว่าคุณจะต้องรันด้วยคำสั่ง `cargo build --release` และเอาตัว executable ใน *target/release* ไปทำการทดสอบนะ

### Cargo as Convention

กับโปรเจ็คง่าย คุณจะไม่ค่อยเห็นประโยชน์ของ Cargo มากนัก แค่ใช้ `rustc` ก็เพียงพอแล้ว แต่ถ้าโปรแกรมที่เขียนเริ่มมีความสลับซับซ้อนขึ้น ใช้ crates มากขึ้น Cargo จะแสดงศักยภาพให้เห็นว่ามันช่วยให้ชีวิตคุณง่ายขึ้นแค่ไหน

แต่ถึงแม้ว่าโปรเจ็ค `hello_cargo` ของเรามันจะดูง่ายมาก แต่เราก็ได้ลองใช้เครื่องมือจริงๆที่คุณจะได้ใช้ทำมาหากินได้ตลอด และความจริง เวลาทำงานกับโปรเจ็คเก่าๆ คุณสามารถใช้คำสั่งนี้ดึงโค้ดลงมาแล้วก็ลองบิวด์มันตามนี้ได้เลย:

```text
$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
```

สำหรับข้อมูลเพิ่มเติมเกี่ยวกับ Cargo ให้ตามไปดูในเอกสารได้ที่ [its documentation]

[its documentation]: https://doc.rust-lang.org/cargo/

## สรุป

ถึงตอนนี้คุณก็ได้จบการเริ่มต้นมหากาพย์อันยิ่งใหญ่แห่ง Rust เรียบร้อยแล้ว โดยในบทนี้คุณได้เรียนรู้ว่า:

* การติดตั้ง Rust เวอร์ชั่นที่เสถียรล่าสุดด้วย `rustup`
* การอัพเดทเวอร์ Rust ชั่นใหม่
* การเปิดเอกสารการติดตั้งบนเครื่องคุณเอง
* เขียนและรันโปรแกรม Hello, world~ ด้วยการใช้ `rustc` ตรงๆ
* เขียนและรันโปรเจ็คใหม่ด้วย Cargo

และตอนนี้ก็น่าจะเป็นเวลาที่ดีที่สุดที่เราจะมาเขียนโปรแกรมกันจริงๆจังๆ โดยในบทที่ 2 เราจะมาสร้างเกมทายตัวเลขกัน แต่ถ้าคุณอยากจะเริ่มจากคอนเซ็ปท์ทั่วไปของ Rust ให้ไปอ่านบทที่ 3 ก่อนก็ได้ แล้วค่อยกลับมาอ่านบทที่ 2 อีกที

[installation]: ch01-01-installation.html#installation
